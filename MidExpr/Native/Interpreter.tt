<#@ template language="C#" #>
<#@ output extension=".cc" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>// generated by template, do not modify manually
<#
    var regs = 8; // 8 vector128

    var calc_ops = new[] { "Add", "Sub", "Mul", "Div" };
    var cmp_ops = new[] { "eq", "ne", "lt", "gt", "le", "ge" };
    var sigs = new[] { "I", "U" };
    var i_sizes = new[] { 1, 2, 4, 8 };
    var f_sizes = new[] { 4, 8 };

    string GetVConv(int size, bool sig = false) => size switch {
        2 => sig ? ".i16" : ".u16",
        4 => sig ? ".i32" : ".u32",
        8 => sig ? ".i64" : ".u64",
        _ => sig ? ".i8" : ".u8" };

    string GetVConvF(int size) => size switch {
        8 => ".f64",
        _ => ".f32" };

    string GetPConv(int size, bool use_byte = false) => size switch {
        2 => "reinterpret_cast<uint16_t*>",
        4 => "reinterpret_cast<uint32_t*>",
        8 => "reinterpret_cast<uint64_t*>",
        _ => use_byte ? "reinterpret_cast<uint8_t*>" : "" };

    string GetCVConv(int size, bool sig = false) => size switch {
        2 => sig ? "static_cast<int16_t>" : "static_cast<uint16_t>",
        4 => sig ? "static_cast<int32_t>" : "static_cast<uint32_t>",
        8 => sig ? "static_cast<int64_t>" : "static_cast<uint64_t>",
        _ => sig ? "static_cast<int8_t>" : "static_cast<uint8_t>" };

    string GetCVConvF(int size) => size switch {
        8 => "static_cast<double>",
        _ => "static_cast<float>" };

    string GetCalcOp(string calc) => calc switch {
        "Sub" => "-",
        "Mul" => "*",
        "Div" => "/",
        _ => "+"  };

    string GetCmpOp(string calc) => calc switch {
        "ne" => "!=",
        "lt" => "<",
        "gt" => ">",
        "le" => "<=",
        "ge" => ">=",
        _ => "=="  };
#>

// ReSharper disable CppRedundantCastExpression
// ReSharper disable CppIdenticalOperandsInBinaryExpression
#include "Interpreter.h"

using namespace Coplt;

void Coplt::Coplt_MidInterpreter_Exec(
    const MidFunc* root_func,
    MidRegs* regs,
    char* stack_data,
    MidFrame* stack_frames,
    uint32_t stack_data_len,
    uint32_t stack_frames_len
)
{
<#
    for (var i = 0; i < regs; i++)
    {
#>
    auto r<#= i #> = regs->r<#= i #>;
<#
    }
#>

    auto func = root_func;
    auto frames = stack_frames;
    auto stack = stack_data;
    auto calc_stack = stack + func->m_all_local_size;
    auto frame_count = 0u;
    auto code_offset = 0u;

Re:
    auto p_code = func->m_code.data();
    auto code = p_code + code_offset;
Next:
    // ReSharper disable once CppDefaultCaseNotHandledInSwitchStatement
    // ReSharper disable once CppIncompleteSwitchStatement
    switch (static_cast<OpCode>(*code))
    {
        case OpCode::Nop: code++; goto Next;

        case OpCode::Ret:
        {
            if (frame_count == 0) goto Ret;
            auto& frame = frames[--frame_count];
            func = frame.m_func;
            stack = frame.m_p_stack;
            calc_stack = frame.m_p_calc_stack;
            code_offset = frame.m_code_offset;
            goto Re;
        }

        case OpCode::Call:
        {
            auto& frame = frames[frame_count++];
            frame.m_func = func;
            frame.m_p_stack = stack;
            frame.m_p_calc_stack = calc_stack;
            frame.m_code_offset = static_cast<uint32_t>(code - p_code + 2);
            func = func->m_fns.data()[*(code + 1)]; // NOLINT(*-simplify-subscript-expr)
            code_offset = 0;
            goto Re;
        }

<#
    for (var i = 0; i < regs; i++)
    {
#>
        case OpCode::LdNull_R<#= i #>: r<#= i #> = {}; code++; goto Next;
<#
    }
#>
<#
    for (var i = 0; i < regs; i++)
    {
#>

        case OpCode::Ldc_R<#= i #>_I4_M1:
            r<#= i #> = -1; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_I4_0:
            r<#= i #> = 0; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_I4_1:
            r<#= i #> = 1; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_I4_2:
            r<#= i #> = 2; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_I4_3:
            r<#= i #> = 3; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_I4_5:
            r<#= i #> = 5; code++; goto Next;

        case OpCode::Ldc_R<#= i #>_F4_1:
            r<#= i #> = 1.0f; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_F4_M1:
            r<#= i #> = -1.0f; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_F4_2:
            r<#= i #> = 2.0f; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_F4_05: // 0.5
            r<#= i #> = 0.5f; code++; goto Next;
        case OpCode::Ldc_R<#= i #>_F4_M05: // -0.5
            r<#= i #> = -0.5f; code++; goto Next;

        case OpCode::Ldc_R<#= i #>_X4: // <op> <4 byte value>
            r<#= i #> = *reinterpret_cast<const int32_t*>(code + 1); code += 3; goto Next;
        case OpCode::Ldc_R<#= i #>_X8: // <op> <8 byte value>
            r<#= i #> = *reinterpret_cast<const int64_t*>(code + 1); code += 5; goto Next;
<#
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
        foreach (var size in i_sizes)
        {
            var p_conv = GetPConv(size, true);
#>
        case OpCode::LdLoc_R<#= i #>_X<#= size #>: // <op> <u2 offset (4 byte step)>
            r<#= i #> = *<#= p_conv #>(stack + 4 * *(code + 1)); code += 2; goto Next;
<#
        }
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
#>
        case OpCode::LdLocA_R<#= i #>: // <op> <u2 offset (4 byte step)>
            r<#= i #> = reinterpret_cast<size_t>(stack + 4 * *(code + 1)); code += 2; goto Next;
<#
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var v_conv = GetVConv(size);
                var p_conv = GetPConv(size, true);
#>
        case OpCode::LdInd_R<#= d #>_R<#= s #>_X<#= size #>:
            r<#= d #> = *<#= p_conv #>(r<#= s #>.usize); code++; goto Next;
<#
            }
        }
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var v_conv = GetVConv(size);
                var p_conv = GetPConv(size, true);
#>
        case OpCode::StInd_R<#= d #>_R<#= s #>_X<#= size #>:
            *<#= p_conv #>(r<#= d #>.usize) = r<#= s #><#= v_conv #>; code++; goto Next;
<#
            }
        }
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
        foreach (var size in f_sizes)
        {
            var v_conv = GetVConv(size);
            var p_conv = GetPConv(size);
#>
        case OpCode::Push_R<#= i #>_X<#= size #>:
            *<#= p_conv #>(calc_stack) = r<#= i #><#= v_conv #>; calc_stack += <#= size #>; code++; goto Next;
<#
        }
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
        foreach (var size in i_sizes)
        {
            var v_conv = GetVConv(size);
            var p_conv = GetPConv(size);
#>
        case OpCode::Pop_R<#= i #>_X<#= size #>:
            calc_stack -= <#= Math.Max(size, 4) #>; r<#= i #><#= v_conv #> = *<#= p_conv #>(calc_stack); code++; goto Next;
<#
        }
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var v_conv = GetVConv(size);
#>
        case OpCode::Mov_R<#= d #>_R<#= s #>_X<#= size #>:
            r<#= d #> = r<#= s #><#= v_conv #>; code++; goto Next;
<#
            }
        }
    }
#>
<#
    foreach (var sig in sigs)
    {
        foreach (var size in i_sizes)
        {
            var v_conv = GetVConv(size, sig == "I");
            var cv_conv = GetCVConv(size, sig == "I");

            foreach (var calc in calc_ops)
            {
                var op = GetCalcOp(calc);
#>

<#
                for (var d = 0; d < regs; d++)
                {
                    for (var s = 0; s < regs; s++)
                    {
#>
        case OpCode::<#= calc #><#= sig #>_R<#= d #>_R<#= s #>_X<#= size #>:
            r<#= d #> = <#= cv_conv #>(r<#= d #><#= v_conv #> <#= op #> r<#= s #><#= v_conv #>); code++; goto Next;
<#
                    }
                }
            }
        }
    }
#>
<#
    foreach (var size in f_sizes)
    {
        var cv_conv = GetCVConvF(size);
        var v_conv = GetVConvF(size);
        foreach (var calc in calc_ops)
        {
            var op = GetCalcOp(calc);
#>

<#
            for (var d = 0; d < regs; d++)
            {
                for (var s = 0; s < regs; s++)
                {
#>
        case OpCode::<#= calc #>F_R<#= d #>_R<#= s #>_X<#= size #>:
            r<#= d #> = <#= cv_conv #>(r<#= d #><#= v_conv #> <#= op #> r<#= s #><#= v_conv #>); code++; goto Next;
<#
                }
            }
        }
    }
#>
        case OpCode::Br: // <op> <u2 op offset>
            code += *(code + 1); goto Next;

<#
    for (var d = 0; d < regs; d++)
    {
#>
        case OpCode::BTrue_R<#= d #>: // <op> <u2 op offset>
            code += r<#= d #>.u64 == 0 ? 2 : *(code + 1); goto Next;
<#
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
#>
        case OpCode::BFalse_R<#= d #>: // <op> <u2 op offset>
            code += r<#= d #>.u64 != 0 ? 2 : *(code + 1); goto Next;
<#
    }
#>
<#
    foreach (var cmp in cmp_ops)
    {
        var op = GetCmpOp(cmp);
#>

<#
        for (var d = 0; d < regs; d++)
        {
            for (var s = 0; s < regs; s++)
            {
#>
        case OpCode::B<#= cmp #>I_R<#= d #>_R<#= s #>: // <op> <u2 op offset>
            code += r<#= d #>.u64 <#= op #> r<#= s #>.u64 ? *(code + 1) : 2; goto Next;
<#
            }
        }
    }
#>
<#
    foreach (var size in f_sizes)
    {
        var v_conv = GetVConvF(size);

        foreach (var cmp in cmp_ops)
        {
            var op = GetCmpOp(cmp);
#>

<#
            for (var d = 0; d < regs; d++)
            {
                for (var s = 0; s < regs; s++)
                {
#>
        case OpCode::B<#= cmp #>F<#= size #>_R<#= d #>_R<#= s #>: // <op> <u2 op offset>
            code += r<#= d #><#= v_conv #> <#= op #> r<#= s #><#= v_conv #> ? *(code + 1) : 2; goto Next;
<#
                }
            }
        }
    }
#>
}

Ret:
<#
    for (var i = 0; i < regs; i++)
    {
#>
    regs->r<#= i #> = r<#= i #>;
<#
    }
#>
}
