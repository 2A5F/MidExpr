<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Linq" #>// generated by template, do not modify manually

<#
    var regs = 8; // 8 vector128

    var calc_ops = new[] { "Add", "Sub", "Mul", "Div" };
    var cmp_ops = new[] { "eq", "ne", "lt", "gt", "le", "ge" };
    var sigs = new[] { "I", "U" };
    var i_sizes = new[] { 1, 2, 4, 8 };
    var f_sizes = new[] { 4, 8 };

    string GetVConv(int size, bool sig = false) => size switch {
        2 => sig ? ".AsInt16()" : ".AsUInt16()",
        4 => sig ? ".AsInt32()" : ".AsUInt32()",
        8 => sig ? ".AsInt64()" : ".AsUInt64()",
        _ => sig ? ".AsSByte()" : "" };

    string GetVConvF(int size) => size switch {
        8 => ".AsDouble()",
        _ => ".AsSingle()" };

    string GetPConv(int size, bool use_byte = false) => size switch {
        2 => "(ushort*)",
        4 => "(uint*)",
        8 => "(ulong*)",
        _ => use_byte ? "(byte*)" : "" };

    string GetVMask(int size) => size switch {
        2 => "Vector128.CreateScalar(ushort.MaxValue).AsByte()",
        4 => "Vector128.CreateScalar(uint.MaxValue).AsByte()",
        8 => "Vector128.CreateScalar(ulong.MaxValue).AsByte()",
        _ => "Vector128.CreateScalar(byte.MaxValue)" };

    string GetCalcOp(string calc) => calc switch {
        "Sub" => "-",
        "Mul" => "*",
        "Div" => "/",
        _ => "+"  };

    string GetCmpOp(string calc) => calc switch {
        "ne" => "!=",
        "lt" => "<",
        "gt" => ">",
        "le" => "<=",
        "ge" => ">=",
        _ => "=="  };
#>
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;

namespace MidExpr;

public static unsafe class MidInterpreter2
{
    public static void Exec(ushort[] codes, byte* stack)
    {
<#
    for (var i = 0; i < regs; i++)
    {
#>
        Vector128<byte> r<#= i #> = default;
<#
    }
#>
        fixed (ushort* p_code = codes)
        {
            var code = p_code;
            Next:
            switch ((OpCode2)(*code))
            {
                case OpCode2.Nop: code++; goto Next;

                case OpCode2.Ret: throw new NotImplementedException("todo Ret");

                case OpCode2.Call: throw new NotImplementedException("todo Call");
                case OpCode2.CallInd: throw new NotImplementedException("todo CallInd");

<#
    for (var i = 0; i < regs; i++)
    {
#>
                case OpCode2.LdNull_R<#= i #>: r<#= i #> = default; code++; goto Next;
<#
    }
#>
<#
    for (var i = 0; i < regs; i++)
    {
#>

                case OpCode2.Ldc_R<#= i #>_I4_M1:
                    r<#= i #> = Vector128.CreateScalar(-1).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_I4_0:
                    r<#= i #> = Vector128.CreateScalar(0).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_I4_1:
                    r<#= i #> = Vector128.CreateScalar(1).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_I4_2:
                    r<#= i #> = Vector128.CreateScalar(2).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_I4_3:
                    r<#= i #> = Vector128.CreateScalar(3).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_I4_5:
                    r<#= i #> = Vector128.CreateScalar(5).AsByte(); code++; goto Next;

                case OpCode2.Ldc_R<#= i #>_F4_1:
                    r<#= i #> = Vector128.CreateScalar(1f).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_F4_M1:
                    r<#= i #> = Vector128.CreateScalar(-1f).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_F4_2:
                    r<#= i #> = Vector128.CreateScalar(2f).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_F4_05: // 0.5
                    r<#= i #> = Vector128.CreateScalar(0.5f).AsByte(); code++; goto Next;
                case OpCode2.Ldc_R<#= i #>_F4_M05: // -0.5
                    r<#= i #> = Vector128.CreateScalar(-0.5f).AsByte(); code++; goto Next;

                case OpCode2.Ldc_R<#= i #>_X4: // <op> <4 byte value>
                    r<#= i #> = Vector128.CreateScalar(*(int*)(code + 1)).AsByte(); code += 3; goto Next;
                case OpCode2.Ldc_R<#= i #>_X8: // <op> <8 byte value>
                    r<#= i #> = Vector128.CreateScalar(*(long*)(code + 1)).AsByte(); code += 5; goto Next;
<#
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
        foreach (var size in i_sizes)
        {
            var p_conv = GetPConv(size);
#>
                case OpCode2.LdLoc_R<#= i #>_X<#= size #>: // <op> <u2 offset (4 byte step)>
                    r<#= i #> = Vector128.CreateScalar(*<#= p_conv #>(stack + 4 * *(code + 1))).AsByte(); code += 2; goto Next;
<#
        }
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
        foreach (var size in i_sizes)
        {
            var v_conv = GetVConv(size);
            var p_conv = GetPConv(size);
#>
                case OpCode2.StLoc_R<#= i #>_X<#= size #>: // <op> <u2 offset (4 byte step)>
                    *<#= p_conv #>(stack + 4 * *(code + 1)) = r<#= i #><#= v_conv #>[0]; code += 2; goto Next;
<#
        }
    }
#>

<#
    for (var i = 0; i < regs; i++)
    {
#>
                case OpCode2.LdLocA_R<#= i #>: // <op> <u2 offset (4 byte step)>
                    r<#= i #> = Vector128.CreateScalar((nuint)(stack + 4 * *(code + 1))).AsByte(); code += 2; goto Next;
<#
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var p_conv = GetPConv(size, true);
#>
                case OpCode2.LdInd_R<#= d #>_R<#= s #>_X<#= size #>:
                    r<#= d #> = Vector128.CreateScalar(*<#= p_conv #>r<#= s #>.AsNUInt()[0]).AsByte(); code++; goto Next;
<#
            }
        }
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var v_conv = GetVConv(size);
                var p_conv = GetPConv(size, true);
#>
                case OpCode2.StInd_R<#= d #>_R<#= s #>_X<#= size #>:
                    *<#= p_conv #>r<#= d #>.AsNUInt()[0] = r<#= s #><#= v_conv #>[0]; code++; goto Next;
<#
            }
        }
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
        for (var s = 0; s < regs; s++)
        {
            foreach (var size in i_sizes)
            {
                var mask = GetVMask(size);
#>
                case OpCode2.Mov_R<#= d #>_R<#= s #>_XR<#= size #>:
                    r<#= d #> = r<#= s #> & <#= mask #>; code++; goto Next;
<#
            }
        }
    }
#>
<#
    foreach (var sig in sigs)
    {
        foreach (var size in i_sizes)
        {
            var v_conv = GetVConv(size, sig == "I");

            foreach (var calc in calc_ops)
            {
                var op = GetCalcOp(calc);
#>

<#
                for (var d = 0; d < regs; d++)
                {
                    for (var s = 0; s < regs; s++)
                    {
#>
                case OpCode2.<#= calc #><#= sig #>_R<#= d #>_R<#= s #>_X<#= size #>:
                    r<#= d #> = (r<#= d #><#= v_conv #> <#= op #> r<#= s #><#= v_conv #>).AsByte(); code++; goto Next;
<#
                    }
                }
            }
        }
    }
#>
<#
    foreach (var size in f_sizes)
    {
        var v_conv = GetVConvF(size);
        foreach (var calc in calc_ops)
        {
            var op = GetCalcOp(calc);
#>

<#
            for (var d = 0; d < regs; d++)
            {
                for (var s = 0; s < regs; s++)
                {
#>
                case OpCode2.<#= calc #>F_R<#= d #>_R<#= s #>_X<#= size #>:
                    r<#= d #> = (r<#= d #><#= v_conv #> <#= op #> r<#= s #><#= v_conv #>).AsByte(); code++; goto Next;
<#
                }
            }
        }
    }
#>

                case OpCode2.Br: // <op> <u2 op offset>
                    code += *(code + 1); goto Next;

<#
    for (var d = 0; d < regs; d++)
    {
#>
                case OpCode2.BTrue_R<#= d #>: // <op> <u2 op offset>
                    code += r<#= d #> == default ? 2 : *(code + 1); goto Next;
<#
    }
#>

<#
    for (var d = 0; d < regs; d++)
    {
#>
                case OpCode2.BFalse_R<#= d #>: // <op> <u2 op offset>
                    code += r<#= d #> != default ? 2 : *(code + 1); goto Next;
<#
    }
#>
<#
    foreach (var cmp in cmp_ops)
    {
        var op = GetCmpOp(cmp);
#>

<#
        for (var d = 0; d < regs; d++)
        {
            for (var s = 0; s < regs; s++)
            {
#>
                case OpCode2.B<#= cmp #>I_R<#= d #>_R<#= s #>: // <op> <u2 op offset>
                    code += r<#= d #>.AsUInt64()[0] <#= op #> r<#= s #>.AsUInt64()[0] ? 2 : *(code + 1); goto Next;
<#
            }
        }
    }
#>
<#
    foreach (var size in f_sizes)
    {
        var v_conv = GetVConvF(size);

        foreach (var cmp in cmp_ops)
        {
            var op = GetCmpOp(cmp);
#>

<#
            for (var d = 0; d < regs; d++)
            {
                for (var s = 0; s < regs; s++)
                {
#>
                case OpCode2.B<#= cmp #>F<#= size #>_R<#= d #>_R<#= s #>: // <op> <u2 op offset>
                    code += r<#= d #><#= v_conv #>[0] <#= op #> r<#= s #><#= v_conv #>[0] ? 2 : *(code + 1); goto Next;
<#
                }
            }
        }
    }
#>
                default:
                    throw new ArgumentOutOfRangeException();
            }
        }
    }
}
